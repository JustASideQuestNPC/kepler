// kepler.collider is part of Kepler, a 2D game engine for p5.js
// https://github.com/JustASideQuestNPC/kepler
!function(t){t.COLLIDER_INCLUDED=!0;class i{x;y;w;h;constructor(t,i,s,e){this.x=t,this.y=i,this.w=s,this.h=e}intersectsBBox(t){return!(t.x>this.x+this.w||t.x+t.w<this.x||t.y>this.y+this.h||t.y+t.h<this.y)}copy(){return new i(this.x,this.y,this.w,this.h)}}function s(t){let s=1/0,e=-1/0,o=1/0,n=-1/0;for(let r of t)r.x<s&&(s=r.x),r.x>e&&(e=r.x),r.y<o&&(o=r.y),r.y>n&&(n=r.y);return new i(s,o,e-s,n-o)}function e(t,i){let s;return p5.Vector.dist(i.start,t.position)+p5.Vector.dist(i.end,t.position)==p5.Vector.dist(i.start,i.end)}function o(t,i){return p5.Vector.sub(t.position,i.position).magSq()<i.radiusSq}function n(t,i){let s=!1,e=i.points;for(let o=0,n=e.length-1;o<e.length;n=o++){let r=e[o],h=e[n];r.y>t.y!=h.y>t.y&&t.x<(h.x-r.x)*(t.y-r.y)/(h.y-r.y)+r.x&&(s=!s)}return s}function r(t,i,s,e){let o=p5.Vector.sub(i,t),n=p5.Vector.sub(e,s),r=(-o.y*(t.x-s.x)+o.x*(t.y-s.y))/(-n.x*o.y+o.x*n.y),h=(n.x*(t.y-s.y)-n.y*(t.x-s.x))/(-n.x*o.y+o.x*n.y);return r>=0&&r<=1&&h>=0&&h<=1}function h(t,i,s,e,o,n){return o.set(l(t,i,s,n)),p5.Vector.sub(o,s).magSq()<=pow(e,2)}function l(t,i,s,e){let o=p5.Vector.sub(s,t),n=p5.Vector.sub(i,t),r=e.constrain(p5.Vector.dot(o,n)/n.magSq(),0,1);return e.createVector(t.x+n.x*r,t.y+n.y*r)}function c(t,i){if(n(t.start,i)||n(t.end,i))return!0;for(let s=0,e=i.points.length-1;s<i.points.length;e=s++)if(r(i.points[s],i.points[e],t.start,t.end))return!0;return!1}function a(t,s,e,o,r){if(!new i(t.position.x-t.radius,t.position.y-t.radius,2*t.radius,2*t.radius).intersectsBBox(s.bbox))return!1;let c=t.position.copy();if(n(c,s)){let a=r.createVector(),d=1/0;for(let u=0,x=s.points.length-1;u<s.points.length;x=u++){let p,y=l(s.points[u],s.points[x],c,r);y.dist(c)<d&&(d=y.dist(c),a.set(y))}if(c.set(a),null!=e){let f=r.createVector();f.set(p5.Vector.sub(c,t.position)),f.setMag(f.mag()+t.radius),o&&f.set(-f.x,-f.y),e.set(f)}return!0}let g=r.createVector(),$=1/0;for(let b=0,V=s.points.length-1;b<s.points.length;V=b++){let C=s.points[b],_=s.points[V],P=r.createVector();if(h(C,_,c,t.radius,P,r)){let B=P.dist(c);B<$&&($=B,g.set(P))}}if($<1/0){if(null!=e){let k=p5.Vector.sub(g,t.position),m=t.radius-k.mag();k.setMag(-m),o&&k.set(-k.x,-k.y),e.set(k)}return!0}return!1}function d(t,i){let s=1/0,e=-1/0;for(let o of t.points){let n=o.dot(i);n<s&&(s=n),n>e&&(e=n)}return[s,e]}function u(t,i){return t[0]<i[0]?i[0]-t[1]:t[0]-i[1]}function x(t,i){let s=[];for(let e=0,o=t.points.length-1;e<t.points.length;o=e++){let n=t.points[e],r=t.points[o];s.push(i.createVector(n.x-r.x,n.y-r.y))}return s}t.PointCollider=class{#a;position;get x(){return this.position.x}set x(t){this.position.x=t}get y(){return this.position.y}set y(t){this.position.y=t}constructor({x:t,y:i,sketch:s}){this.#a=s,this.position=this.#a.createVector(t,i)}render(t=this.#a){t.point(this.position.x,this.position.y)}isColliding(i){return i instanceof t.PointCollider?Math.floor(this.position.x)===Math.floor(i.position.x)&&Math.floor(this.position.y)===Math.floor(i.position.y):i instanceof t.LineCollider?e(this,i):i instanceof t.CircleCollider?o(this,i):i instanceof t.PolygonCollider?n(this.position,i):void 0}},t.LineCollider=class{#a;start;end;constructor({start:t,end:i,sketch:s}){this.#a=s,this.start=s.createVector(t.x,t.y),this.end=s.createVector(i.x,i.y)}setPos(t,i){if(t instanceof p5.Vector){let s=p5.Vector.sub(this.end,this.start);this.start.set(t),this.end.set(p5.Vector.add(this.start,s))}else{let e=this.end.x-this.start.x,o=this.end.y-this.start.y;this.start.set(t,i),this.end.set(t+e,i+o)}}modPos(t,i){t instanceof p5.Vector?(this.start.add(t),this.end.add(t)):(this.start.add(t,i),this.end.add(t,i))}render(t=this.#a){t.line(this.start.x,this.start.y,this.end.x,this.end.y)}isColliding(i){if(i instanceof t.PointCollider)return e(i,this);if(i instanceof t.LineCollider)return r(this.start,this.end,i.start,i.end,this.#a);if(i instanceof t.CircleCollider){let s=this.#a.createVector();return h(this.start,this.end,i.position,i.radius,s,this.#a)}if(i instanceof t.PolygonCollider)return c(this,i)}},t.CircleCollider=class{#a;get radius(){return this.#b}set radius(t){this.#b=t,this.#c=t*t}get radiusSq(){return this.#c}position;get x(){return this.position.x}set x(t){this.position.x=t}get y(){return this.position.y}set y(t){this.position.y=t}#b;#c;constructor({x:t,y:i,radius:s,sketch:e}){this.#a=e,this.position=e.createVector(t,i),this.radius=s}render(t=this.#a){t.ellipse(this.position.x,this.position.y,2*this.#b,2*this.#b)}isColliding(i,s=null){if(i instanceof t.PointCollider)return o(i,this);if(i instanceof t.LineCollider){let e=this.#a.createVector();return h(i.start,i.end,this.position,this.radius,e,this.#a)}return i instanceof t.CircleCollider?function t(i,s,e,o){let n=o.createVector(i.position.x-s.position.x,i.position.y-s.position.y);if(n.magSq()<pow(i.radius+s.radius,2)){if(null!=e){let r=o.createVector(n.x,n.y);r.setMag(i.radius+s.radius),r.sub(n),e.set(r)}return!0}return!1}(this,i,s,this.#a):i instanceof t.PolygonCollider?a(this,i,s,!1,this.#a):void 0}},t.PolygonCollider=class{#a;get points(){return this.#d}get bbox(){return this.#e}#f=createVector(0,0);get position(){return this.#f.copy()}#d=[];#g=[];#h=[];#e;#i;#j;get angle(){return this.#j}constructor({points:t,x:i=0,y:e=0,sketch:o}){for(let n of(this.#a=o,t))this.#d.push(o.createVector(n[0],n[1])),this.#g.push(o.createVector(n[0],n[1])),this.#h.push(o.createVector(n[0],n[1]));this.#i=s(this.#h),this.#e=this.#i.copy(),this.setPos(i,e),this.#j=0}setPos(t,i){t instanceof p5.Vector?this.#f.set(t):this.#f.set(t,i);for(let s=0;s<this.#h.length;++s)this.#d[s].set(this.#h[s].x+t,this.#h[s].y+i);this.#e.x=this.#i.x+t,this.#e.y=this.#i.y+i}modPos(t,i){for(let s of(t instanceof p5.Vector&&(i=t.y,t=t.x),this.#d))s.x+=t,s.y+=i;this.#e.x+=t,this.#e.y+=i}setAngle(t){this.#j=t;for(let i=0;i<this.#g.length;++i)this.#h[i].set(p5.Vector.rotate(this.#g[i],t));this.#i=s(this.#h),this.#e=this.#i.copy(),this.setPos(this.#f.x,this.#f.y)}modAngle(t){for(let i of(this.#j+=t,this.#h))i.rotate(t);this.#i=s(this.#h),this.#e=this.#i.copy(),this.setPos(this.#f.x,this.#f.y)}render(t=this.#a){for(let i of(t.rect(this.#e.x,this.#e.y,this.#e.w,this.#e.h),t.beginShape(),this.#d))t.vertex(i.x,i.y);t.endShape(CLOSE)}isColliding(i,s=null){return i instanceof t.PointCollider?n(i.position,this,this.#a):i instanceof t.LineCollider?c(i,this):i instanceof t.CircleCollider?a(i,this,s,!0,this.#a):i instanceof t.PolygonCollider?function t(i,s,e,o){if(!i.bbox.intersectsBBox(s.bbox))return!1;let n=x(i,o),r=x(s,o),h=n.concat(r),l=1/0,c=o.createVector(0,0);for(let a of h){let p=a.mag(),y=o.createVector(-a.y/p,a.x/p),f=d(i,y),g=d(s,y),$=u(f,g);if($>0)return!1;abs($)<l&&(l=abs($),f[0]<g[0]?c.set(-y.x,-y.y):c.set(y.x,y.y))}return null!=e&&e.set(p5.Vector.mult(c,l)),!0}(this,i,s,this.#a):void 0}}}(window.Kepler=window.Kepler||{});