// kepler.collider is part of Kepler, a 2D game engine for p5.js
// https://github.com/JustASideQuestNPC/kepler
!function(t){t.COLLIDER_INCLUDED=!0;class i{constructor(t,i,s,e){this.x=t,this.y=i,this.w=s,this.h=e}intersectsBBox(t){return!(t.x>this.x+this.w||t.x+t.w<this.x||t.y>this.y+this.h||t.y+t.h<this.y)}copy(){return new i(this.x,this.y,this.w,this.h)}}function s(t){let s=1/0,e=-1/0,o=1/0,r=-1/0;for(let n of t)n.x<s&&(s=n.x),n.x>e&&(e=n.x),n.y<o&&(o=n.y),n.y>r&&(r=n.y);return new i(s,o,e-s,r-o)}function e(t,i){let s;return p5.Vector.dist(i.start,t.position)+p5.Vector.dist(i.end,t.position)==p5.Vector.dist(i.start,i.end)}function o(t,i){return p5.Vector.sub(t.position,i.position).magSq()<i.radiusSq}function r(t,i){let s=!1,e=i.points;for(let o=0,r=e.length-1;o<e.length;r=o++){let n=e[o],h=e[r];n.y>t.y!=h.y>t.y&&t.x<(h.x-n.x)*(t.y-n.y)/(h.y-n.y)+n.x&&(s=!s)}return s}function n(t,i,s,e){let o=p5.Vector.sub(i,t),r=p5.Vector.sub(e,s),n=(-o.y*(t.x-s.x)+o.x*(t.y-s.y))/(-r.x*o.y+o.x*r.y),h=(r.x*(t.y-s.y)-r.y*(t.x-s.x))/(-r.x*o.y+o.x*r.y);return n>=0&&n<=1&&h>=0&&h<=1}function h(t,i,s,e,o,r){return o.set(c(t,i,s,r)),p5.Vector.sub(o,s).magSq()<=pow(e,2)}function c(t,i,s,e){let o=p5.Vector.sub(s,t),r=p5.Vector.sub(i,t),n=e.constrain(p5.Vector.dot(o,r)/r.magSq(),0,1);return e.createVector(t.x+r.x*n,t.y+r.y*n)}function l(t,i){if(r(t.start,i)||r(t.end,i))return!0;for(let s=0,e=i.points.length-1;s<i.points.length;e=s++)if(n(i.points[s],i.points[e],t.start,t.end))return!0;return!1}function a(t,s,e,o,n){if(!new i(t.position.x-t.radius,t.position.y-t.radius,2*t.radius,2*t.radius).intersectsBBox(s.bbox))return!1;let l=t.position.copy();if(r(l,s)){let a=n.createVector(),u=1/0;for(let d=0,x=s.points.length-1;d<s.points.length;x=d++){let p,y=c(s.points[d],s.points[x],l,n);y.dist(l)<u&&(u=y.dist(l),a.set(y))}if(l.set(a),null!=e){let f=n.createVector();f.set(p5.Vector.sub(l,t.position)),f.setMag(f.mag()+t.radius),o&&f.set(-f.x,-f.y),e.set(f)}return!0}let b=n.createVector(),g=1/0;for(let $=0,V=s.points.length-1;$<s.points.length;V=$++){let _=s.points[$],C=s.points[V],P=n.createVector();if(h(_,C,l,t.radius,P,n)){let B=P.dist(l);B<g&&(g=B,b.set(P))}}if(g<1/0){if(null!=e){let k=p5.Vector.sub(b,t.position),m=t.radius-k.mag();k.setMag(-m),o&&k.set(-k.x,-k.y),e.set(k)}return!0}return!1}function u(t,i){let s=1/0,e=-1/0;for(let o of t.points){let r=o.dot(i);r<s&&(s=r),r>e&&(e=r)}return[s,e]}function d(t,i){return t[0]<i[0]?i[0]-t[1]:t[0]-i[1]}function x(t,i){let s=[];for(let e=0,o=t.points.length-1;e<t.points.length;o=e++){let r=t.points[e],n=t.points[o];s.push(i.createVector(r.x-n.x,r.y-n.y))}return s}t.PointCollider=class{get x(){return this.position.x}set x(t){this.position.x=t}get y(){return this.position.y}set y(t){this.position.y=t}constructor({x:t,y:i,sketch:s}){this._sketch=s,this.position=this._sketch.createVector(t,i)}render(t=this._sketch){t.point(this.position.x,this.position.y)}isColliding(i){return i instanceof t.PointCollider?Math.floor(this.position.x)===Math.floor(i.position.x)&&Math.floor(this.position.y)===Math.floor(i.position.y):i instanceof t.LineCollider?e(this,i):i instanceof t.CircleCollider?o(this,i):r(this.position,i)}},t.LineCollider=class{constructor({start:t,end:i,sketch:s}){this._sketch=s,this.start=s.createVector(t.x,t.y),this.end=s.createVector(i.x,i.y)}setPos(t,i){if(t instanceof p5.Vector){let s=p5.Vector.sub(this.end,this.start);this.start.set(t),this.end.set(p5.Vector.add(this.start,s))}else{let e=this.end.x-this.start.x,o=this.end.y-this.start.y;this.start.set(t,i),this.end.set(t+e,i+o)}}modPos(t,i){t instanceof p5.Vector?(this.start.add(t),this.end.add(t)):(this.start.add(t,i),this.end.add(t,i))}render(t=this._sketch){t.line(this.start.x,this.start.y,this.end.x,this.end.y)}isColliding(i){if(i instanceof t.PointCollider)return e(i,this);if(i instanceof t.LineCollider)return n(this.start,this.end,i.start,i.end,this._sketch);if(!(i instanceof t.CircleCollider))return l(this,i);{let s=this._sketch.createVector();return h(this.start,this.end,i.position,i.radius,s,this._sketch)}}},t.CircleCollider=class{get radius(){return this._radius}set radius(t){this._radius=t,this._radiusSq=t*t}get radiusSq(){return this._radiusSq}get x(){return this.position.x}set x(t){this.position.x=t}get y(){return this.position.y}set y(t){this.position.y=t}constructor({x:t,y:i,radius:s,sketch:e}){this._sketch=e,this.position=e.createVector(t,i),this.radius=s}render(t=this._sketch){t.ellipse(this.position.x,this.position.y,2*this._radius,2*this._radius)}isColliding(i,s=null){if(i instanceof t.PointCollider)return o(i,this);if(i instanceof t.LineCollider){let e=this._sketch.createVector();return h(i.start,i.end,this.position,this.radius,e,this._sketch)}return i instanceof t.CircleCollider?function t(i,s,e,o){let r=o.createVector(i.position.x-s.position.x,i.position.y-s.position.y);if(r.magSq()<pow(i.radius+s.radius,2)){if(null!=e){let n=o.createVector(r.x,r.y);n.setMag(i.radius+s.radius),n.sub(r),e.set(n)}return!0}return!1}(this,i,s,this._sketch):a(this,i,s,!1,this._sketch)}},t.PolygonCollider=class{get points(){return this._points}get bbox(){return this._bbox}get position(){return this._position.copy()}get angle(){return this._angle}constructor({points:t,x:i=0,y:e=0,sketch:o}){for(let r of(this._sketch=o,this._position=o.createVector(0,0),this._points=[],this._absolutePoints=[],this._rotatedPoints=[],t))this._points.push(o.createVector(r[0],r[1])),this._absolutePoints.push(o.createVector(r[0],r[1])),this._rotatedPoints.push(o.createVector(r[0],r[1]));this._rotatedBBox=s(this._rotatedPoints),this._bbox=this._rotatedBBox.copy(),this.setPos(i,e),this._angle=0}setPos(t,i){t instanceof p5.Vector?this._position.set(t):this._position.set(t,i);for(let s=0;s<this._rotatedPoints.length;++s)this._points[s].set(this._rotatedPoints[s].x+t,this._rotatedPoints[s].y+i);this._bbox.x=this._rotatedBBox.x+t,this._bbox.y=this._rotatedBBox.y+i}modPos(t,i){for(let s of(t instanceof p5.Vector&&(i=t.y,t=t.x),this._points))s.x+=t,s.y+=i;this._bbox.x+=t,this._bbox.y+=i}setAngle(t){this._angle=t;for(let i=0;i<this._absolutePoints.length;++i)this._rotatedPoints[i].set(p5.Vector.rotate(this._absolutePoints[i],t));this._rotatedBBox=s(this._rotatedPoints),this._bbox=this._rotatedBBox.copy(),this.setPos(this._position.x,this._position.y)}modAngle(t){for(let i of(this._angle+=t,this._rotatedPoints))i.rotate(t);this._rotatedBBox=s(this._rotatedPoints),this._bbox=this._rotatedBBox.copy(),this.setPos(this._position.x,this._position.y)}render(t=this._sketch){for(let i of(t.rect(this._bbox.x,this._bbox.y,this._bbox.w,this._bbox.h),t.beginShape(),this._points))t.vertex(i.x,i.y);t.endShape(CLOSE)}isColliding(i,s=null){return i instanceof t.PointCollider?r(i.position,this,this._sketch):i instanceof t.LineCollider?l(i,this):i instanceof t.CircleCollider?a(i,this,s,!0,this._sketch):function t(i,s,e,o){if(!i.bbox.intersectsBBox(s.bbox))return!1;let r=x(i,o),n=x(s,o),h=r.concat(n),c=1/0,l=o.createVector(0,0);for(let a of h){let p=a.mag(),y=o.createVector(-a.y/p,a.x/p),f=u(i,y),b=u(s,y),g=d(f,b);if(g>0)return!1;abs(g)<c&&(c=abs(g),f[0]<b[0]?l.set(-y.x,-y.y):l.set(y.x,y.y))}return null!=e&&e.set(p5.Vector.mult(l,c)),!0}(this,i,s,this._sketch)}}}(window.Kepler=window.Kepler||{});